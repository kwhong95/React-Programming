# 6.1 리덕스 사용 시 따라야 할 세 가지 원칙

1) 전체 상태값을 하나의 객체에 저장한다.
2) 상태값은 불변 객체이다.
3) 상태값은 순수 함수에 의해서만 변경되어야 한다.

### 하나의 객체에 프로그램의 전체 상태값을 저장한다
> 전체 상태값이 하나의 자바스크립트 객체로 표현되기 때문에 활용도가 높아짐

- 리덕스 사용 시 하나의 객체를 **직렬화(serialize)** 해서 서버와 클라이언트가 프로그램의 전체 상태값을 주고 받을 수 있음
- 프로그램이 특정한 상태에 있을 때 발생하는 버그를 확인하기 위해 그 상태값을 저장한 후 반복해서 재현 가능
- 최근 상태값을 버리지 않고 저장해 놓으면 실행 취소(undo)와 다시 실행(redo) 기능을 쉽게 구현 가능
- 전체적으로 리덕스로 상태값을 관리하기 보단 필요한 부분에만 적용하는 것이 생산성을 높임

### 상태값을 불변 객체로 관리한다
#### 상태값은 오직 액션 객체에 의해서만 변경된다
```js
const incrementAction = { // 1
  type: 'INCREMENT',
  amount: 123,
};
const conditionalIncrementAction = { // 2
  type: 'CONDITIONAL_INCREMENT',
  amount: 2,
  gt: 10,
  lt: 100,
};
store.dispatch(incrementAction); // 3
store.dispatch(conditionalIncrementAction); // 3
```
1) 액션 객체는 `type` 속성값이 존재해야 함
2) `type` 속성값을 제외한 나머지는 상태값을 수정하기 위해 사용되는 정보
3) 액션 객체와 함께 `dispatch` 메서드를 호출하면 상태값이 변경

- 리덕스의 상태값을 수정하는 유일한 방법은 액션 객체와 함께 `dispatch` 메서드를 호출하는 것
  + 다른 어떤 방뻡으로도 상태값을 수정하면 안됨
  + 상태값은 `dispatch` 메서드가 호출된 순서대로 리덕스 내부에서 변경되기 떄문에 상태값이 변화하는 과정을 쉽게 이해할 수 있음
  + 액션 객체는 평범한 자바스크립트 객체이기 때문에 입력된 순서를 저장해 놓고 나중에 그 과정을 쉽게 재현할 수 있음
- 상태값 수정이라는 하나의 목적만 놓고 보면 불변 객체를 사용하는 것보단 상태값을 직접 수정하는 것이 빠름
  + 이전 상태값과 이후 상태값을 비교해서 변경 여부를 파악할 때는 불변 객체가 훨씬 유리
  + 상태값 변경을 빠르게 확인할 수 있으면 메모이제이션과 같은 기능을 활용하기 좋고, 렌더링 성능을 올리는 데도 유리

### 오직 순수 함수에 의해서만 상태값을 변경해야 한다
> 리덕스에서 상태값을 변경하는 함수를 **리듀서(reducer)** 라고 부른다

#### 리덕스의 구조
```js
(state, action) => nextState
```

- 리듀서는 이전 상태값과 액션 객체를 입력으로 받아서 새로운 상태값을 만드는 순수함수
  + 순수 함수는 부수 효과(side effect)를 발생시키면 안됨
  + 순수 함수는 같은 인수에 대해 항상 같은 값을 반환해야 함
  
#### 시간 함수를 사용하면 순수 함수가 아니다
```js
// 홍길동님 안녕하세요, 지금은 11시 30분입니다.
sayHello1('홍길동');
sayHello2('홍길동', '11:30');
```

- `sayHello1` 함수는 내부적으로 시간 함수를 호출하기 때문에 순수 함수가 아님
  + 같은 인수를 입력해도 호출하는 시점에 따라 다른 값을 반환하기 때문
- `sayHello2` 함수는 순수함수, 같은 인수를 입력하면 항상 같은 값을 반환함

#### 순수 함수는 테스트 코드를 작성하기 쉽다
```js
const now = new Date();
const hour = now.getHours();
const minute = now.getMinutes();
expect(sayHello1('홍길동')).toBe(
  `홍길동님 안녕하세요, 지금은 ${hour}시 ${minute}분입니다.`,
);

expect(sayHello2('홍길동', '11:30')).toBe(
  '홍길동님 안녕하세요. 지금은 11시 30분입니다.',
);
```

1) `sayHello1` 함수는 내부적으로 현재 시각을 사용하기 때문에 테스트 코드에서도 현재 시각을 가져와야 함, 하지만 현재 시각을 가져오는 시점이 항상 다르기 때문에 간헐적으로 테스트가 실패할 수 있음, 일정 수준의 오차는 허용하도록 테스트 코드를 작성할 수 있으나 번거로움
2) 순수 함수로 작성한 코드는 별다른 고민 없이 쉽게 테스트 코드를 작성할 수 있음

- 리듀서는 순수 함수이기 때문에 같은 상태값과 액션 객체를 입력하면 항상 똑같은 다음 상태값을 반환, 실행된 액션 객체를  순서대로 저장했다가 나중에 똑같은 순서대로 `dispatch` 메서드를 호출핳면 싑게 리플레이(replay) 기능을 구현할 수 있음

